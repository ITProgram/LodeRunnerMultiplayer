<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Phaser TEst Samples</title>

    <script type="text/javascript" src="/lib/phaser.js"></script>
    <script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>
    <!--<script type="text/javascript" src="https://github.com/photonstorm/phaser/releases/download/v2.6.2/phaser.min.js"></script>-->
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body onresize="resizeCanvas()">


<script type="text/javascript">

    function resizeCanvas()
    {
//        game.scale.refresh();
    }

    var socket = io.connect('http://192.168.100.2');
    //var socket = io.connect('http://192.168.0.102');


    const VELOCITY = 192;
    const VELOCITY_LEFT = 8;

    ////////////////////////////////////////
    /*var SAFE_ZONE_WIDTH = 1920;
     var SAFE_ZONE_HEIGHT = 1080;
     var w = window.innerWidth;//* pixelRatio,
     h = window.innerHeight;//* pixelRatio;
     var lw, lh; //landscape width/height in pixels
     if (h > w) {
     lw = h;
     lh = w;
     } else {
     lw = w;
     lh = h;
     }
     var aspectRatioDevice = lw / lh;

     var aspectRatioSafeZone = SAFE_ZONE_WIDTH / SAFE_ZONE_HEIGHT;
     var extraWidth = 0, extraHeight = 0;
     if (aspectRatioSafeZone < aspectRatioDevice) {
     // have to add game pixels vertically in order to fill the device screen
     extraWidth = aspectRatioDevice * SAFE_ZONE_HEIGHT - SAFE_ZONE_WIDTH;
     } else {
     // have to add game pixels horizontally
     extraHeight = SAFE_ZONE_WIDTH / aspectRatioDevice - SAFE_ZONE_HEIGHT;
     }

     //var game = new Phaser.Game( (h > w) ? h : w, (h > w) ? w : h, Phaser.CANVAS, 'game_div');
     //var game = new Phaser.Game( SAFE_ZONE_WIDTH, SAFE_ZONE_HEIGHT, Phaser.AUTO, 'game_div');
     //var game = new Phaser.Game(SAFE_ZONE_WIDTH + extraWidth, SAFE_ZONE_HEIGHT + extraHeight, Phaser.CANVAS, 'game_div');

     */
    ///////////////////////////////////////////////
    //var game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.CANVAS, '', {
    //    onresize="()=> {  this.game.scale.refresh();}"
    var sizeX = 1920;
    var sizeY = 1080;
    var aspectRatio = window.innerWidth / window.innerHeight;
    var aspectRatio;
    if (aspectRatio != 1920 / 1080 || aspectRatio != 1080 / 1920) {
        if (window.innerWidth > window.innerHeight) {
            sizeX = 1080 * aspectRatio;

        } else {
            sizeY = 1920 * aspectRatio;
        }

    }
    var game = new Phaser.Game(sizeX, sizeY, Phaser.CANVAS, '', {
        preload: preload,
        create: create,
        update: update,
        render: render
    });
    var map;
    var layer;
    var player;

    var tileCurrent;
    var tileUpperUpper;
    var tileRightSide;
    var tileRightUnder;
    var tileUnderUnder;
    var tileLeftSide;
    var tileLeftUnder;

    function preload() {
        //////////////

        game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
        game.scale.pageAlignHorizontally = true;
        game.scale.pageAlignVertically = true;

        ///////////////////

        ////////////////////


        game.load.tilemap('map', "assets/map3.csv", null, Phaser.Tilemap.CSV);
        //game.load.image('tileset', "assets/NES - Lode Runner - Tileset.png");
        game.load.image('tileset', "assets/bricksx64.png");
        game.load.spritesheet('dude', 'assets/dude.png', 64, 64);
    }

    function create() {



        /*game.input.keyboard.onUpCallback = function (e) {
         // These can be checked against Phaser.Keyboard.UP, for example.
         if (e.keyCode === cursors.up.keyCode)
         console.log(e.keyCode + '=' + cursors.up.keyCode);
         else
         console.log(e.keyCode + '!=' + cursors.up.keyCode);
         };
         */
        map = game.add.tilemap('map', 64, 64);
        map.addTilesetImage('tileset');
        layer = map.createLayer(0);

        layer.resizeWorld();
        map.setCollision(0);
        game.time.advancedTiming = true;    // for debug
        player = game.add.sprite(300, 6000, 'dude');
        player.anchor.set(0.5);
        game.physics.arcade.enable(player);
        //player.body.TILE_BITS=64;
        game.camera.follow(player);
        player.body.gravity.y = 1000;


        player.body.collideWorldBounds = true;
        player.animations.add('left', [0, 1, 2, 3], 10, true);
        player.animations.add('right', [5, 6, 7, 8], 10, true);
        cursors = game.input.keyboard.createCursorKeys();
        game.physics.startSystem(Phaser.Physics.ARCADE);


        game.input.keyboard.onUpCallback = (e) => {


            if (e.keyCode == cursors.right.keyCode) {
                player.body.velocity.x = 0;
                //               game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                ``
                //socket.emit('keyEvent', {name: 'right', state: 'false', x: player.body.x, y: player.body.y});
            } else if (e.keyCode == cursors.left.keyCode) {
                player.body.velocity.x = 0;
                //             game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                //socket.emit('keyEvent', {name: 'left', state: 'false', x: player.body.x, y: player.body.y});
            } else if (e.keyCode == cursors.up.keyCode) {
                if (player.body.allowGravity != true) {
                    game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                    player.body.velocity.y = 0;
                }
                // socket.emit('keyEvent', {name: 'up', state: 'false', x: player.body.x, y: player.body.y});
            } else if (e.keyCode == cursors.down.keyCode) {
                if (player.body.allowGravity != true) {
                    game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                    player.body.velocity.y = 0;
                }
                //socket.emit('keyEvent', {name: 'down', state: 'false', x: player.body.x, y: player.body.y});
            } else if (e.keyCode == Phaser.KeyCode.G) {
                player.body.gravity.y = 1000;
            }
        };
        game.input.addPointer();
        //layer.debug = true;
    }
    function update() {

        var collideSprvsLayer = game.physics.arcade.collide(player, layer);

        tileCurrent = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64), layer.getTileY(Math.floor(player.y / 64) * 64));
        tileUpperUpper = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64), layer.getTileY(Math.floor(player.y / 64) * 64) - 1);
        tileRightSide = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64) + 1, layer.getTileY(Math.floor(player.y / 64) * 64));
        tileRightUnder = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64) + 1, layer.getTileY(Math.floor(player.y / 64) * 64) + 1);
        tileUnderUnder = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64), layer.getTileY(Math.floor(player.y / 64) * 64) + 1);
        tileLeftSide = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64) - 1, layer.getTileY(Math.floor(player.y / 64) * 64));
        tileLeftUnder = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64) - 1, layer.getTileY(Math.floor(player.y / 64) * 64) + 1);


        if (cursors.left.isDown) {//&& player.body.onFloor()
            //socket.emit('keyEvent', {name: 'left', state: 'true'});

            player.body.velocity.x = -VELOCITY;
            player.animations.play('left');
        }
        else if (cursors.right.isDown /*&& (player.body.onFloor() )*/) {
            player.body.velocity.x = VELOCITY;
            /*socket.emit('keyEvent', {
             name: 'right',
             state: 'true',
             x: Math.floor(player.body.x),
             y: Math.floor(player.body.y)
             });
             */
            player.animations.play('right');
        }



        /*
         //ВНИЗ
         if (cursors.down.isDown && ((tileCurrent.index == 2)
         || (tileCurrent.index = 1 && tileUnderUnder.index == 2))) {
         player.body.velocity.y = VELOCITY;
         if (tileUnderUnder.index != 2)
         player.body.allowGravity = true;
         //socket.emit('keyEvent', {name: 'down', state: 'true', x: player.body.x, y: player.body.y});
         //player.animations.play('right');
         }//ВВЕРХ
         else if (cursors.up.isDown) {
         if ((tileCurrent.index == 2)) {
         player.body.allowGravity = false;
         player.body.velocity.y = -VELOCITY;
         //                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

         }
         else if (tileCurrent.index = 1 && tileUnderUnder.index == 2) {
         // player.body.allowGravity = true;
         game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

         }//player.body.touching.down**
         }
         *///
        else if (cursors.up.isDown) {
            if ((tileCurrent.index == 2 )) {
                player.body.allowGravity = false;
                player.body.velocity.y = -VELOCITY;
                /*по Х*/
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
            }

            else if (tileCurrent.index == 1 && tileUnderUnder.index == 2) {
                player.body.allowGravity = false;

                game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

            }//player.body.touching.down**

        }
        //ВНИЗ
        else if (cursors.down.isDown) {
            if (tileUnderUnder.index == 2 && tileCurrent.index == 2) {
                player.body.velocity.y = VELOCITY;
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
            }
            else if (tileCurrent.index != 2 && tileUnderUnder.index != 2) {
                if (!player.body.allowGravity)
                    player.body.allowGravity = true;
            }
            else if (tileCurrent.index == 1 && tileUnderUnder.index == 2) {
                player.body.velocity.y = VELOCITY;
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

            } else if (tileCurrent.index == 2 && tileUnderUnder.index == 1) {
                player.body.velocity.y = VELOCITY;
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
            }

            //socket.emit('keyEvent', {name: 'down', state: 'true', x: player.body.x, y: player.body.y});
        }
        /*//ВНИЗ
         else if (cursors.down.isDown /*&&((tileCurrent.index == 2)
         || (tileCurrent.index = 1 && tileUnderUnder.index == 2))**) {
         player.body.velocity.y = VELOCITY;
         game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
         if (tileUnderUnder.index != 2) {
         player.body.allowGravity = true;
         }
         //socket.emit('keyEvent', {name: 'down', state: 'true', x: player.body.x, y: player.body.y});
         }
         */

        else if (game.input.keyboard.isDown(Phaser.KeyCode.X)) {
            if (tileRightSide.index != 0 && tileRightUnder.index == 0 && (tileUnderUnder.index == 0 || tileUnderUnder.index == 2)) {
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                map.putTile(3, tileRightUnder.x, tileRightUnder.y);
            }
            /*
             if (tileRightUnder.index == 0
             && tileRightSide.index != 0
             && tileRightUnder.index != 1) {
             game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
             map.putTile(1, tileRightUnder.x, tileRightUnder.y);
             }
             */

        }
        //справа копать
        /*else if (game.input.keyboard.isDown(Phaser.KeyCode.X) && player.body.onFloor()) {

         if (tileRightUnder.index == 0
         && tileRightSide.index != 0
         && tileRightUnder.index != 1) {
         game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
         map.putTile(1, tileRightUnder.x, tileRightUnder.y);
         }

         }*/
        else if (game.input.keyboard.isDown(Phaser.KeyCode.Z)) {
            if (tileLeftSide.index != 0 && tileLeftUnder.index == 0 && (tileUnderUnder.index == 0 || tileUnderUnder.index == 2)) {
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                map.putTile(3, tileLeftUnder.x, tileLeftUnder.y);
            }
            /*if (tileLeftUnder.index == 0
             && tileLeftSide.index != 0
             && tileLeftUnder.index != 1) {

             }*/
        }
        /*else if (game.input.keyboard.isDown(Phaser.KeyCode.Z) && player.body.onFloor()) {
         if (tileLeftUnder.index == 0
         && tileLeftSide.index != 0
         && tileLeftUnder.index != 1) {
         game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
         map.putTile(1, tileLeftUnder.x, tileLeftUnder.y);
         }
         }*/
        else if (game.input.keyboard.isDown(Phaser.KeyCode.G)) {
            player.body.gravity.y = 11000;
        }
        else {
            player.animations.stop();
            player.frame = 4;
        }

        if ((tileCurrent.index == 2 || tileUnderUnder.index == 2) && !cursors.up.isDown && !cursors.down.isDown) {
            player.body.allowGravity = false;
            //player.body.velocity.y=0;
            game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

        }

        if (!player.body.onFloor() /*|| tileUnderUnder.index == 1*/) {
            if ((tileUnderUnder.index == 1 || tileUnderUnder.index == 3) && tileCurrent.index != 2) {//прыжок с обрыва
                player.body.velocity.x = 0;
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                //game.add.tween(player).to({y: game.math.snapTo(player.y-64, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                //player.body.x = game.math.snapTo(player.body.x, 64);
                player.body.allowGravity = true;
            }
            else if ((tileUnderUnder.index == 0 || tileUnderUnder.index == 3) && tileCurrent.index != 2) {
                player.body.allowGravity = true;
            }
            //here edited in the train
            else if (tileCurrent.index == 1 && tileUnderUnder.index == 2 && !cursors.down.isDown) {
                player.body.velocity.y = 0;
                game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

            }
        }
        else if (player.body.onFloor() && tileUnderUnder.index == 3 && tileCurrent.index != 2) {

            game.add.tween(player).to({y: game.math.snapTo(player.y + 64, 64, 32)}, 50, Phaser.Easing.Linear.None, true);
            player.body.allowGravity = true;
        }

        /*else if ( tileUnderUnder.index == 1) {
         game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
         console.log("111");
         }
         */
    }

    function render() {

        if (game.time.fps > 30)
            game.debug.text(game.time.fps || '--', 2, 14, "#00ff00");
        else
            game.debug.text(game.time.fps || '--', 2, 14, "#ff1800");
        /* game.debug.pointer(game.input.mousePointer);
         game.debug.pointer(game.input.pointer1);
         */

        game.debug.text(player.body.onFloor().toString(), 300, 10);

        game.debug.text(tileLeftSide.index + ' ' + tileCurrent.index + ' ' + tileRightSide.index, 10, 10);
        game.debug.text(tileLeftUnder.index + ' ' + tileUnderUnder.index + ' ' + tileRightUnder.index, 10, 20);
        game.debug.text(player.body.gravity.y, 10, 30);
        game.debug.text(player.body.velocity.y, 10, 40);
        game.debug.text(player.body.allowGravity, 10, 50);


        game.debug.text(player.body.blocked.up, 10, 100);
        game.debug.text(player.body.blocked.down, 10, 110);
        game.debug.text(player.body.blocked.right, 10, 120);
        game.debug.text(player.body.blocked.left, 10, 130);


        game.debug.text(aspectRatio, 10, 200);

        // game.debug.text(collided, 10, 100);
    }
    ////////////////////////////////////////////////////////////////////////
    socket.on('spawn', function (data) {
        if (player) {
            player.id = data.id;
            player.x = data.x;
            player.y = data.y;
        }

    });

    socket.on('newPositions', function (data) {
        for (var i in data) {
            if (data[i].id === player.id) {
                //game.add.tween(player).to( { x:data[i].x  }, 100, Phaser.Easing.Linear.None, true);
                //            game.add.tween(player).to( { x:game.math.snapTo(player.x,64,32)  }, 10, Phaser.Easing.Linear.None, true);
                player.body.x = data[i].x;
                //              player.body.y = data[i].y;
            }
            //console.log(data[i].id + ' ' + data[i].x + ' ' + data[i].y);
            //game.add.tween(player).to({x: game.math.snapTo(player.x, 32)}, 1, Phaser.Easing.Linear.None, true);

        }
    });

    /*socket.on('move', function (data) {

     /*if (data.v != 0) {
     if (player.body.velocity.x != data.v)
     player.body.velocity.x = data.v;
     } else
     player.body.velocity.x = 0;
     */
    //player.x= game.math.snapTo(player.x,64);
    //game.add.tween(player).to( { x:game.math.snapTo(player.x,64,32)  }, 10, Phaser.Easing.Linear.None, true);
    //player.x= game.math.snapTo(player.x,64,32);
    //console.log(player.x);
    //player.x+=10;
    //console.log(data);
    //socket.emit('my other event', { my: 'data' });
    //});


</script>
</body>
</html>


<!--



1. send to server and processing here
2. server add to quee 11111111111111111
3.after processing send to al clients objects info with velocity
4.get and correct positions

-->