<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Phaser TEst Samples</title>

    <script type="text/javascript" src="/lib/phaser.js"></script>
    <script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>
    <!--<script type="text/javascript" src="https://github.com/photonstorm/phaser/releases/download/v2.6.2/phaser.min.js"></script>-->
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>


<script type="text/javascript">
    function resizeCanvas() {
//        game.scale.refresh();
    }
    var socket = io.connect('http://192.168.100.4');


    var players = [];
    const VELOCITY = 192;
    ////////////////////////////////////////
    /*var SAFE_ZONE_WIDTH = 1920;
     var SAFE_ZONE_HEIGHT = 1080;
     var w = window.innerWidth;//* pixelRatio,
     h = window.innerHeight;//* pixelRatio;
     var lw, lh; //landscape width/height in pixels
     if (h > w) {
     lw = h;
     lh = w;
     } else {
     lw = w;
     lh = h;
     }
     var aspectRatioDevice = lw / lh;

     var aspectRatioSafeZone = SAFE_ZONE_WIDTH / SAFE_ZONE_HEIGHT;
     var extraWidth = 0, extraHeight = 0;
     if (aspectRatioSafeZone < aspectRatioDevice) {
     // have to add game pixels vertically in order to fill the device screen
     extraWidth = aspectRatioDevice * SAFE_ZONE_HEIGHT - SAFE_ZONE_WIDTH;
     } else {
     // have to add game pixels horizontally
     extraHeight = SAFE_ZONE_WIDTH / aspectRatioDevice - SAFE_ZONE_HEIGHT;
     }

     //var game = new Phaser.Game( (h > w) ? h : w, (h > w) ? w : h, Phaser.CANVAS, 'game_div');
     //var game = new Phaser.Game( SAFE_ZONE_WIDTH, SAFE_ZONE_HEIGHT, Phaser.AUTO, 'game_div');
     //var game = new Phaser.Game(SAFE_ZONE_WIDTH + extraWidth, SAFE_ZONE_HEIGHT + extraHeight, Phaser.CANVAS, 'game_div');

     */
    ///////////////////////////////////////////////

    var sizeX = 1920;
    var sizeY = 1080;
    var aspectRatio = window.innerWidth / window.innerHeight;
    //var aspectRatio;
    if (aspectRatio != 1920 / 1080 || aspectRatio != 1080 / 1920) {
        if (window.innerWidth > window.innerHeight)
            sizeX = 1080 * aspectRatio;
        else
            sizeY = 1920 * aspectRatio;
    }

    var game = new Phaser.Game(sizeX, sizeY, Phaser.CANVAS, '', {
        preload: preload,
        create: create,
        update: update,
        render: render
    });
    var map;
    var layer;
    var player;

    var tileCurrent;
    var tileUpperUpper;
    var tileRightSide;
    var tileRightUnder;
    var tileUnderUnder;
    var tileLeftSide;
    var tileLeftUnder;

    function preload() {
        game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
        game.scale.pageAlignHorizontally = true;
        game.scale.pageAlignVertically = true;

        game.load.tilemap('map', "assets/map3.csv", null, Phaser.Tilemap.CSV);
        //game.load.image('tileset', "assets/NES - Lode Runner - Tileset.png");
        game.load.image('tileset', "assets/bricksx64.png");
        game.load.spritesheet('dude', 'assets/dude.png', 64, 64);
    }

    function create() {
        map = game.add.tilemap('map', 64, 64);
        map.addTilesetImage('tileset');
        layer = map.createLayer(0);

        layer.resizeWorld();
        map.setCollision(0);
        game.time.advancedTiming = true;    // for debug

        player = game.add.sprite(256, 6000, 'dude');
        player.anchor.set(0.5);
        game.physics.arcade.enable(player);
        //player.body.TILE_BITS=64;
        game.camera.follow(player);
        player.body.gravity.y = 1000;

        player.body.collideWorldBounds = true;
        player.animations.add('left', [0, 1, 2, 3], 10, true);
        player.animations.add('right', [5, 6, 7, 8], 10, true);
        ////////////////////
        cursors = game.input.keyboard.createCursorKeys();
        game.physics.startSystem(Phaser.Physics.ARCADE);

        game.input.keyboard.onUpCallback = (e) => {
            //({type: 'keys', clientID: data.clientID, key: data.key, state: data.state,   data.velocityX, data.velocityY})

            if (e.keyCode == cursors.right.keyCode) {
                player.body.velocity.x = 0;
                //               game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

                socket.emit('keys', {
                    clientID: clid,
                    key: 'right',
                    state: 'false',
                    x: player.body.x,
                    y: player.body.y,
                    velocityX: player.body.velocity.x,
                    velocityY: player.body.velocity.y
                });
            } else if (e.keyCode == cursors.left.keyCode) {
                player.body.velocity.x = 0;
                //             game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                socket.emit('keys', {
                    clientID: clid,
                    key: 'right',
                    state: 'false',
                    x: player.body.x,
                    y: player.body.y,
                    velocityX: player.body.velocity.x,
                    velocityY: player.body.velocity.y
                });
            } else if (e.keyCode == cursors.up.keyCode) {
                if (player.body.allowGravity != true) {
                    game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                    player.body.velocity.y = 0;
                }
                socket.emit('keys', {
                    clientID: clid,
                    key: 'right',
                    state: 'false',
                    x: player.body.x,
                    y: player.body.y,
                    velocityX: player.body.velocity.x,
                    velocityY: player.body.velocity.y
                });
            } else if (e.keyCode == cursors.down.keyCode) {
                if (player.body.allowGravity != true) {
                    game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                    player.body.velocity.y = 0;
                }
                socket.emit('keys', {
                    clientID: clid,
                    key: 'right',
                    state: 'false',
                    x: player.body.x,
                    y: player.body.y,
                    velocityX: player.body.velocity.x,
                    velocityY: player.body.velocity.y
                });
            } else if (e.keyCode == Phaser.KeyCode.G) {
                player.body.gravity.y = 1000;
            }
        };
        game.input.addPointer();
        //layer.debug = true;
    }

    function update() {

        var collideSprvsLayer = game.physics.arcade.collide(player, layer);

        tileCurrent = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64), layer.getTileY(Math.floor(player.y / 64) * 64));
        tileUpperUpper = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64), layer.getTileY(Math.floor(player.y / 64) * 64) - 1);
        tileRightSide = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64) + 1, layer.getTileY(Math.floor(player.y / 64) * 64));
        tileRightUnder = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64) + 1, layer.getTileY(Math.floor(player.y / 64) * 64) + 1);
        tileUnderUnder = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64), layer.getTileY(Math.floor(player.y / 64) * 64) + 1);
        tileLeftSide = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64) - 1, layer.getTileY(Math.floor(player.y / 64) * 64));
        tileLeftUnder = map.getTile(layer.getTileX(Math.floor(player.x / 64) * 64) - 1, layer.getTileY(Math.floor(player.y / 64) * 64) + 1);


        if (cursors.left.isDown) {//&& player.body.onFloor()
            player.body.velocity.x = -VELOCITY;
            player.animations.play('left');
            socket.emit('keys', {
                clientID: clid,
                key: 'left',
                state: 'false',
                x: player.body.x,
                y: player.body.y,
                velocityX: player.body.velocity.x,
                velocityY: player.body.velocity.y
            });

        }
        else if (cursors.right.isDown /*&& (player.body.onFloor() )*/) {
            player.body.velocity.x = VELOCITY;
            /*socket.emit('keyEvent', {
             name: 'right',
             state: 'true',
             x: Math.floor(player.body.x),
             y: Math.floor(player.body.y)
             });
             */
            player.animations.play('right');
            socket.emit('keys', {
                clientID: clid,
                key: 'right',
                state: 'false',
                x: player.body.x,
                y: player.body.y,
                velocityX: player.body.velocity.x,
                velocityY: player.body.velocity.y
            });
        }
        /*
         //ВНИЗ
         if (cursors.down.isDown && ((tileCurrent.index == 2)
         || (tileCurrent.index = 1 && tileUnderUnder.index == 2))) {
         player.body.velocity.y = VELOCITY;
         if (tileUnderUnder.index != 2)
         player.body.allowGravity = true;
         //socket.emit('keyEvent', {name: 'down', state: 'true', x: player.body.x, y: player.body.y});
         //player.animations.play('right');
         }//ВВЕРХ
         else if (cursors.up.isDown) {
         if ((tileCurrent.index == 2)) {
         player.body.allowGravity = false;
         player.body.velocity.y = -VELOCITY;
         //                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

         }
         else if (tileCurrent.index = 1 && tileUnderUnder.index == 2) {
         // player.body.allowGravity = true;
         game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

         }//player.body.touching.down**
         }
         *///
        else if (cursors.up.isDown) {
            if ((tileCurrent.index == 2 )) {
                player.body.allowGravity = false;
                player.body.velocity.y = -VELOCITY;
                /*по Х*/
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
            }

            else if (tileCurrent.index == 1 && tileUnderUnder.index == 2) {
                player.body.allowGravity = false;

                game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

            }//player.body.touching.down**
            socket.emit('keys', {
                clientID: clid,
                key: 'up',
                state: 'false',
                x: player.body.x,
                y: player.body.y,
                velocityX: player.body.velocity.x,
                velocityY: player.body.velocity.y
            });

        }
        //ВНИЗ
        else if (cursors.down.isDown) {
            if (tileUnderUnder.index == 2 && tileCurrent.index == 2) {
                player.body.velocity.y = VELOCITY;
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
            }
            else if (tileCurrent.index != 2 && tileUnderUnder.index != 2) {
                if (!player.body.allowGravity)
                    player.body.allowGravity = true;
            }
            else if (tileCurrent.index == 1 && tileUnderUnder.index == 2) {
                player.body.velocity.y = VELOCITY;
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

            } else if (tileCurrent.index == 2 && tileUnderUnder.index == 1) {
                player.body.velocity.y = VELOCITY;
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
            }
            //socket.emit('keyEvent', {name: 'down', state: 'true', x: player.body.x, y: player.body.y});
            socket.emit('keys', {
                clientID: clid,
                key: 'down',
                state: 'false',
                x: player.body.x,
                y: player.body.y,
                velocityX: player.body.velocity.x,
                velocityY: player.body.velocity.y
            });

        }
        /*//ВНИЗ
         else if (cursors.down.isDown /*&&((tileCurrent.index == 2)
         || (tileCurrent.index = 1 && tileUnderUnder.index == 2))**) {
         player.body.velocity.y = VELOCITY;
         game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
         if (tileUnderUnder.index != 2) {
         player.body.allowGravity = true;
         }
         //socket.emit('keyEvent', {name: 'down', state: 'true', x: player.body.x, y: player.body.y});
         }
         */

        else if (game.input.keyboard.isDown(Phaser.KeyCode.X)) {
            if (tileRightSide.index != 0 && tileRightUnder.index == 0 && (tileUnderUnder.index == 0 || tileUnderUnder.index == 2)) {
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                map.putTile(3, tileRightUnder.x, tileRightUnder.y);
            }
            /*
             if (tileRightUnder.index == 0
             && tileRightSide.index != 0
             && tileRightUnder.index != 1) {
             game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
             map.putTile(1, tileRightUnder.x, tileRightUnder.y);
             }
             */

        }
        //справа копать
        /*else if (game.input.keyboard.isDown(Phaser.KeyCode.X) && player.body.onFloor()) {

         if (tileRightUnder.index == 0
         && tileRightSide.index != 0
         && tileRightUnder.index != 1) {
         game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
         map.putTile(1, tileRightUnder.x, tileRightUnder.y);
         }

         }*/
        else if (game.input.keyboard.isDown(Phaser.KeyCode.Z)) {
            if (tileLeftSide.index != 0 && tileLeftUnder.index == 0 && (tileUnderUnder.index == 0 || tileUnderUnder.index == 2)) {
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                map.putTile(3, tileLeftUnder.x, tileLeftUnder.y);
            }
            /*if (tileLeftUnder.index == 0
             && tileLeftSide.index != 0
             && tileLeftUnder.index != 1) {

             }*/
        }
        /*else if (game.input.keyboard.isDown(Phaser.KeyCode.Z) && player.body.onFloor()) {
         if (tileLeftUnder.index == 0
         && tileLeftSide.index != 0
         && tileLeftUnder.index != 1) {
         game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
         map.putTile(1, tileLeftUnder.x, tileLeftUnder.y);
         }
         }*/
        else if (game.input.keyboard.isDown(Phaser.KeyCode.G)) {
            player.body.gravity.y = 11000;
        }
        else {
            player.animations.stop();
            player.frame = 4;
        }

        if ((tileCurrent.index == 2 || tileUnderUnder.index == 2) && !cursors.up.isDown && !cursors.down.isDown) {
            player.body.allowGravity = false;
            //player.body.velocity.y=0;
            game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

        }

        if (!player.body.onFloor() /*|| tileUnderUnder.index == 1*/) {
            if ((tileUnderUnder.index == 1 || tileUnderUnder.index == 3) && tileCurrent.index != 2) {//прыжок с обрыва
                player.body.velocity.x = 0;
                game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                //game.add.tween(player).to({y: game.math.snapTo(player.y-64, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
                //player.body.x = game.math.snapTo(player.body.x, 64);
                player.body.allowGravity = true;
            }
            else if ((tileUnderUnder.index == 0 || tileUnderUnder.index == 3) && tileCurrent.index != 2) {
                player.body.allowGravity = true;
            }
            //here edited in the train
            else if (tileCurrent.index == 1 && tileUnderUnder.index == 2 && !cursors.down.isDown) {
                player.body.velocity.y = 0;
                game.add.tween(player).to({y: game.math.snapTo(player.y, 64, 32)}, 1, Phaser.Easing.Linear.None, true);

            }
        }
        else if (player.body.onFloor() && tileUnderUnder.index == 3 && tileCurrent.index != 2) {

            game.add.tween(player).to({y: game.math.snapTo(player.y + 64, 64, 32)}, 50, Phaser.Easing.Linear.None, true);
            player.body.allowGravity = true;
        }

        /*else if ( tileUnderUnder.index == 1) {
         game.add.tween(player).to({x: game.math.snapTo(player.x, 64, 32)}, 1, Phaser.Easing.Linear.None, true);
         console.log("111");
         }
         */
    }
    var clid;
    function render() {
        if (game.time.fps > 30)
            game.debug.text(game.time.fps || '--', 2, 14, "#00ff00");
        else
            game.debug.text(game.time.fps || '--', 2, 14, "#ff1800");
        /* game.debug.pointer(game.input.mousePointer);
         game.debug.pointer(game.input.pointer1);
         */

        game.debug.text(player.body.onFloor().toString(), 300, 10);

        game.debug.text(tileLeftSide.index + ' ' + tileCurrent.index + ' ' + tileRightSide.index, 10, 10);
        game.debug.text(tileLeftUnder.index + ' ' + tileUnderUnder.index + ' ' + tileRightUnder.index, 10, 20);
        game.debug.text(player.body.gravity.y, 10, 30);
        game.debug.text(player.body.velocity.y, 10, 40);
        game.debug.text(player.body.allowGravity, 10, 50);


        game.debug.text(player.body.blocked.up, 10, 100);
        game.debug.text(player.body.blocked.down, 10, 110);
        game.debug.text(player.body.blocked.right, 10, 120);
        game.debug.text(player.body.blocked.left, 10, 130);


        game.debug.text(aspectRatio, 10, 200);

        // game.debug.text(collided, 10, 100);
    }

    ////////////////////////////////////////////////////////////////////////
    socket.on('connected', function (data) {
        players[data.id] = player;
        clid = data.id;
        console.log('Получен id: ' + data.id);
    });

    socket.on('players', function (data) {
        /*packet.push({        id: playersList[i].id,
         x: playersList[i].x,
         y: playersList[i].y,
         velocityX: playersList[i].velocityX,
         velocityY: playersList[i].velocityY,
         pressingButton: 'down'});*/
        /*player = game.add.sprite(300, 6000, 'dude');
         player.anchor.set(0.5);
         game.physics.arcade.enable(player);
         //player.body.TILE_BITS=64;
         game.camera.follow(player);
         player.body.gravity.y = 1000;

         player.body.collideWorldBounds = true;
         */
        for (let i = 0; i < data.length; i++) {

            if (!players[data[i].id]) {
                // players[data[i].id].x=game.math.snapTo(data[i].x, 64,32);
                //players[data[i].id].y=game.math.snapTo(data[i].y, 64,32);
                players[data[i].id] = game.add.sprite(game.math.snapTo(data[i].x, 64, 32), game.math.snapTo(data[i].y, 64, 32), 'dude');
                players[data[i].id].anchor.set(0.5);
                game.physics.arcade.enable(players[data[i].id]);
                //game.math.snapTo(players[data[i].id].x, 64)}, 1, Phaser.Easing.Linear.None, true);

                //players[data[i].id].body.gravity.y = 1000;
                //players[data[i].id].body.collideWorldBounds = true;
            } else if (clid == data[i].id) {

                player.body.x = data[i].x;
                player.body.y = data[i].y;
                players[data[i].id].anchor.set(0.5);
                //game.physics.arcade.enable(player);
                //game.camera.follow(player);
                //player.body.gravity.y = 1000;

                //player.body.collideWorldBounds = true;
                player.animations.add('left', [0, 1, 2, 3], 10, true);
                player.animations.add('right', [5, 6, 7, 8], 10, true);

            }
            else if (players[data[i].id]) {
                players[data[i].id].x = game.math.snapTo(data[i].x, 64, 32);
                players[data[i].id].y = game.math.snapTo(data[i].y, 64, 32);


                players[data[i].id].body.velocity.x = data[i].velocityX;
                players[data[i].id].body.velocity.y = data[i].velocityY;
                players[data[i].id].anchor.set(0.5);


            }
            //console.log(data);
        }
    });

    /*socket.on('move', function (data) {

     /*if (data.v != 0) {
     if (player.body.velocity.x != data.v)
     player.body.velocity.x = data.v;
     } else
     player.body.velocity.x = 0;
     */
    //player.x= game.math.snapTo(player.x,64);
    //game.add.tween(player).to( { x:game.math.snapTo(player.x,64,32)  }, 10, Phaser.Easing.Linear.None, true);
    //player.x= game.math.snapTo(player.x,64,32);
    //console.log(player.x);
    //player.x+=10;
    //console.log(data);
    //socket.emit('my other event', { my: 'data' });
    //});


</script>
</body>
</html>


<!--



1. send to server and processing here
2. server add to quee 11111111111111111
3.after processing send to al clients objects info with velocity
4.get and correct positions






Player
x
y
rightDown
leftDown
UpDown
DownDown
digging
fly

-->